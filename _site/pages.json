[{"layout":"default","title":"Welcome to the BoGL Docs!","content":"# Welcome to the BoGL Docs!\n\nðŸ§  [Tutorials](./tutorials/).\n\n:pencil: [BoGL Online Editor](https://bogl.engr.oregonstate.edu/).\n\n:construction: <span style=\"color:red\">**This site is under construction!**</span>\n<span style=\"color:red\">**Please send feedback and report bugs to <nelsonai@oregonstate.edu>**</span>\n","dir":"/","name":"index.md","path":"index.md","url":"/"},{"permalink":"/tutorials/","layout":"default","title":"Tutorials","content":"<h1 id=\"tutorials\">Tutorials</h1>\n\n<p>Here is a list of the tutorials in the order that we recommend them.</p>\n\n<ol>\n <li><a href=\"basics\">BoGL Basics</a></li>\n <li><a href=\"types\">Types</a></li>\n <li><a href=\"functions\">Functions</a></li>\n</ol>\n\n<p>You can <a href=\"https://the-code-in-sheep-s-clothing.github.io/bogl/Documentation/Syntax\">learn more about our syntax</a> if you want to look into the structure of the language directly.</p>\n","dir":"/tutorials/","name":"README.md","path":"tutorials/README.md","url":"/tutorials/"},{"permalink":"/tutorials/old/","layout":"default","title":"Old Tutorials","content":"<h1 id=\"old-tutorials\">Old Tutorials</h1>\n\n<p>Here is a list of the tutorials in the order that we recommend them.</p>\n\n<ol>\n <li><a href=\"GettingStarted\">Getting Started</a></li>\n <li><a href=\"Intro\">Intro</a></li>\n <li><a href=\"TheGame\">The Game</a></li>\n <li><a href=\"Function\">Your Second Function</a></li>\n <li><a href=\"Input\">Input</a></li>\n <li><a href=\"InARow\">In a Row</a></li>\n <li><a href=\"BoardCount\">Board Count</a></li>\n</ol>\n\n<p>#You can <a href=\"../Documentation/Syntax\">learn more about our syntax</a> if you want to look into the structure of the language directly.</p>\n","dir":"/tutorials/old/","name":"README.md","path":"tutorials/old_tutorials/README.md","url":"/tutorials/old/"},{"sort":1,"permalink":"tutorials/old/:basename:output_ext","layout":"default","title":"Getting Started with BoGL","content":"<h1 id=\"getting-started-with-bogl\">Getting Started with BoGL</h1>\n\n<p>Getting started with BoGL is straightforward, as you can start coding directly in our <a href=\"https://bogl.engr.oregonstate.edu/\">online tool</a>.</p>\n\n<p>Once you have access to the tool you should see the page as follows:\n<img src=\"/imgs/editor-blank.png\" alt=\"The BoGL online tool.\" /></p>\n\n<p>There are 2 main areas of focus.</p>\n\n<p>The white screen on the left is <strong>editor</strong>, this is where you can type in your code to run. A simple BoGL program might be written as follows in the white portion of the screen:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>game Example\n\ntest : Int\ntest = 12345\n</code></pre>  </div></div>\n<p>You may not know exactly what this does yet, but thatâ€™s okay, weâ€™ll get to it later in the tutorial. The important part here is to understand the layout of the tool. Make sure you type this into the white section, and that the tab at the top has â€˜Codeâ€™ selected (not Prelude). The default is to have Code already selected.</p>\n\n<p><img src=\"/imgs/ex-code.png\" alt=\"Showing the test program written into the online tool.\" /></p>\n\n<p>The gray section on the right is the <strong>Interpreter</strong>. It repeats the process of reading the command you entered (an <strong>expression</strong>), evaluating it, and displaying the result. This may sound a bit fancy, but if you type something like <code class=\"language-plaintext highlighter-rouge\">5</code> into the Interpreter, and hit <strong>Enter</strong>, youâ€™ll get back <code class=\"language-plaintext highlighter-rouge\">5</code> (since 5 is 5!). Similarly, typing in a simple expression like <code class=\"language-plaintext highlighter-rouge\">5+5</code> will give you back <code class=\"language-plaintext highlighter-rouge\">10</code>, or <code class=\"language-plaintext highlighter-rouge\">1+2*3</code> will give you back <code class=\"language-plaintext highlighter-rouge\">7</code>. Feel free to play around with some other operators like subtraction, and to get a feel for how you can type in and use expressions.</p>\n\n<p><img src=\"/imgs/ex-5.png\" alt=\"Showing the evaluation of 5 = 5.\" /></p>\n\n<p><img src=\"/imgs/ex-addition.png\" alt=\"Showing the evaluation of 5+5 = 10.\" /></p>\n\n<p><img src=\"/imgs/ex-compound.png\" alt=\"Showing the evaluation of 1+2*3 = 7.\" /></p>\n\n<p>This same gray section is where you can run your BoGL programs, and check the results of interpreting what you typed in. You can also get feedback for errors and issues. When you start a game, you will be able to interact with it from this screen as well. Think of this like your window into the BoGL computer, where you can talk to it, and it can talk back to you. In the case of the simple <code class=\"language-plaintext highlighter-rouge\">Example</code> program we wrote before, you can type <code class=\"language-plaintext highlighter-rouge\">test</code> into the interpreter, hit <strong>Enter</strong>, and you should get back an Integer of <code class=\"language-plaintext highlighter-rouge\">12345</code>!</p>\n\n<p><img src=\"/imgs/ex-test.png\" alt=\"Showing the evaluation of the test program.\" /></p>\n\n<p>One thing that you should keep in mind is that you must have a valid program in the editor (the left white screen) to be able to run anything in the interpreter. This is because BoGL evaluates what you type into the interpreter after first preparing everything you wrote in the white screen. If you have a mistake there, it wonâ€™t be able to get ready to work, and it will indicate that with an error message of some form. If your BoGL program on the left screen is correct, it will be able to prepare and allow you to evaluate expressions normally; as well as have access to anything you wrote in your BoGL program. Any updates you make in the editor on the left will be reflected in the interpreter expression you enter afterwards.\n<a href=\"Intro\">Next, letâ€™s talk about your first BoGL program.</a></p>\n","dir":"/tutorials/old/","name":"GettingStarted.md","path":"tutorials/old_tutorials/GettingStarted.md","url":"/tutorials/old/GettingStarted.html"},{"sort":1,"layout":"default","title":"BoGL Basics","content":"<h1 id=\"bogl-basics\">BoGL Basics</h1>\n<p>Welcome to BoGL, the Board Game Language! These tutorials will teach you the tools youâ€™ll need in order to get started with creating your own programs using this game oriented language.</p>\n\n<h2 id=\"defining-your-game\">Defining your Game</h2>\n<p>Since BoGL is a game themed language, every BoGL program must begin with a game name. You can choose anything for this as long as it is a valid string (no weird characters), starts with a capital letter, and is preceeded by the keyword <code class=\"language-plaintext highlighter-rouge\">Game</code>. Below is an example of the simplest program you can make in BoGL.\n<!-- <link rel=\"stylesheet\" href=\"embed_test.css\"/> -->\n<script src=\"/assets/js/embed_test.js\"></script></p>\n\n<!--The embedded editor START-->\n<div class=\"bogl-embed-editor\">\n <div class=\"bogl\"></div>\n <div class=\"left bogl-code\" contenteditable=\"true\">\n\t \n\t \t\ngame SimplestProgram <br />\n\n\t \n\n </div>\n <div class=\"right\">\n <div class=\"bogl-repl-result\"></div>\n <input class=\"bogl-repl-run\" placeholder=\"&gt;\" type=\"text\" />\n </div>\n</div>\n<p><br />\n<!--END--></p>\n\n<h2 id=\"comments\">Comments</h2>\n<p>Sometimes it can be useful to include comments within your code. Anything written after a double dash <code class=\"language-plaintext highlighter-rouge\">--</code> on a line will be interpreted as comment text, meaning that the interpreter will not interpret that text as BoGL code.\nText can also be marked as comments if it is enclosed by curly bracket-dashes <code class=\"language-plaintext highlighter-rouge\">{- comment text -}</code>.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"c1\">-- Anything after double dashes is comment text</span>\n<span class=\"n\">game</span> <span class=\"kt\">SimplestProgram</span> <span class=\"c1\">-- even if code is on the same line.</span>\n<span class=\"cm\">{-\nComments can be\non multiple lines\nif they are enclosed inside\nof curly bracket-dashes\n-}</span></code></pre>  </figure>\n\n","dir":"/tutorials/","name":"basics.md","path":"tutorials/basics.md","url":"/tutorials/basics.html"},{"sort":2,"layout":"default","title":"Understanding Types","content":"<h1 id=\"understanding-types\">Understanding Types</h1>\n\n<p>Jack and Rosa want to play a board game. They decide that who gets to go first should be determined by the result of a coin toss.</p>\n\n<p>In these first few tutorials, we will create a program using the BoGL language that will take the result of a coin toss and choose who gets to go first based on that result.</p>\n\n<p>In order to do this, our program must be able toâ€¦</p>\n\n<ol>\n <li>Capture the inputted value of the coin toss result.</li>\n <li>Output whether Jack or Rosa gets to go first based off of the result value.</li>\n</ol>\n\n<p><img src=\"/imgs/types-program-diagram.jpg\" alt=\"program input and output diagram\" /></p>\n\n<p>We will start out by creating our game.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"n\">game</span> <span class=\"kt\">WhoGoesFirst</span></code></pre>  </figure>\n\n<p>Next we will capture the coin toss result. For this we are going to create a type that allows us to describe the result of a coin toss.</p>\n\n<p><img src=\"/imgs/types-tossresult-diagram.jpg\" alt=\"toss result variable type diagram\" /></p>\n\n<p>There are currently no defined types for a coin toss result (as there are for integers and booleans), so we will make one ourselves!\nThe pieces of information we need to create our own type are:</p>\n\n<ul>\n <li>The name we want to call our type</li>\n <li>The possible values of our type</li>\n</ul>\n\n<p>To define a type, we must first use the keyword <code class=\"language-plaintext highlighter-rouge\">type</code> in our program, followed by the desired name for our type. It is required by the language that the first letter of this name is capitalized. We will then define what the possible values are for this type using the <code class=\"language-plaintext highlighter-rouge\">=</code> operator, followed then by a list of the possible values, seperated by commas, and contained within <code class=\"language-plaintext highlighter-rouge\">{}</code> brackets. These values will also be given desired names (with their first letters capitalized). It will end up looking like this:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">TossResult</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Heads</span><span class=\"p\">,</span> <span class=\"kt\">Tails</span><span class=\"p\">}</span></code></pre>  </figure>\n\n<p><img src=\"/imgs/types-code-analysis.jpg\" alt=\"analysis of declaring a type\" /></p>\n\n<p>Think of a type as a classification. We, as the programmer, must specify what information is allowed to be classified as our type.\nFor this example we will also be needing a type for the first player (the eventual output of this program).</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">FirstPlayer</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Jack</span><span class=\"p\">,</span> <span class=\"kt\">Rosa</span><span class=\"p\">}</span></code></pre>  </figure>\n\n<p>We will return to this example in the <a href=\"./functions\">functions tutorial</a>, where we will be able to utilize the TossResult type.</p>\n\n<p>Below are a few more examples of user defined types that do not pertain to coin results, just to nail down the concept of defining types!</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"c1\">-- board game themed types</span>\n<span class=\"kr\">type</span> <span class=\"kt\">CardSuit</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Diamond</span><span class=\"p\">,</span> <span class=\"kt\">Club</span><span class=\"p\">,</span> <span class=\"kt\">Heart</span><span class=\"p\">,</span> <span class=\"kt\">Spade</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">PlayerColor</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Blue</span><span class=\"p\">,</span> <span class=\"kt\">Red</span><span class=\"p\">,</span> <span class=\"kt\">Green</span><span class=\"p\">,</span> <span class=\"kt\">Yellow</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">DiceResult</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">One</span><span class=\"p\">,</span> <span class=\"kt\">Two</span><span class=\"p\">,</span> <span class=\"kt\">Three</span><span class=\"p\">,</span> <span class=\"kt\">Four</span><span class=\"p\">,</span> <span class=\"kt\">Five</span><span class=\"p\">,</span> <span class=\"kt\">Six</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ChessPiece</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Pawn</span><span class=\"p\">,</span> <span class=\"kt\">Bishop</span><span class=\"p\">,</span> <span class=\"kt\">Knight</span><span class=\"p\">,</span> <span class=\"kt\">Rook</span><span class=\"p\">,</span> <span class=\"kt\">Queen</span><span class=\"p\">,</span> <span class=\"kt\">King</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ClueCharacter</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">MissScarlett</span><span class=\"p\">,</span> <span class=\"kt\">ColonelMustard</span><span class=\"p\">,</span> <span class=\"kt\">MrsWhite</span><span class=\"p\">,</span> <span class=\"kt\">ReverendGreen</span><span class=\"p\">,</span> <span class=\"kt\">MrsPeacock</span><span class=\"p\">,</span> <span class=\"kt\">ProfessorPlum</span><span class=\"p\">}</span>\n \n<span class=\"c1\">-- non board game themed types</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ClassicIceCreamFlavor</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Vanilla</span><span class=\"p\">,</span> <span class=\"kt\">Chocolate</span><span class=\"p\">,</span> <span class=\"kt\">Strawberry</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">WaterValveState</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Open</span><span class=\"p\">,</span> <span class=\"kt\">Closed</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">StateOfMatter</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Solid</span><span class=\"p\">,</span> <span class=\"kt\">Liquid</span><span class=\"p\">,</span> <span class=\"kt\">Gas</span><span class=\"p\">,</span> <span class=\"kt\">Plasma</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ClothingArticle</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Shirt</span><span class=\"p\">,</span> <span class=\"kt\">Pants</span><span class=\"p\">,</span> <span class=\"kt\">Hat</span><span class=\"p\">,</span> <span class=\"kt\">Shoe</span><span class=\"p\">,</span> <span class=\"kt\">Jacket</span><span class=\"p\">,</span> <span class=\"kt\">Scarf</span><span class=\"p\">,</span> <span class=\"kt\">Glove</span><span class=\"p\">}</span></code></pre>  </figure>\n\n<p>The examples seen above are what we call <a href=\"https://en.wikipedia.org/wiki/Enumerated_type\">enumerated types</a>.\nThere are also two other types built into BoGL: integers and booleans.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kt\">Int</span> <span class=\"c1\">-- Integer type</span>\n<span class=\"kt\">Bool</span> <span class=\"c1\">-- Boolean type</span></code></pre>  </figure>\n\n<p>Numbers are useful! The possible values of the type <code class=\"language-plaintext highlighter-rouge\">Int</code> are all integer values (â€¦, <code class=\"language-plaintext highlighter-rouge\">-2</code>, <code class=\"language-plaintext highlighter-rouge\">-1</code>, <code class=\"language-plaintext highlighter-rouge\">0</code>, <code class=\"language-plaintext highlighter-rouge\">1</code>, <code class=\"language-plaintext highlighter-rouge\">2</code>, <code class=\"language-plaintext highlighter-rouge\">3</code>, â€¦).</p>\n\n<p>Sometimes we just need a binary value. The possible values of the type <code class=\"language-plaintext highlighter-rouge\">Bool</code> are <code class=\"language-plaintext highlighter-rouge\">True</code> and <code class=\"language-plaintext highlighter-rouge\">False</code>.</p>\n\n<p>One more important thing to note about types is that they can be synonyms to other types (see examples below).</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">Score</span> <span class=\"o\">=</span> <span class=\"kt\">Int</span> <span class=\"c1\">-- Score is a synonym of Int, so its possible values are the same as Int.</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ShirtColor</span> <span class=\"o\">=</span> <span class=\"kt\">PlayerColor</span> <span class=\"c1\">-- ShirtColor has the same possible values that PlayerColor (an earlier defined type) has.</span></code></pre>  </figure>\n\n<p><br /></p>\n<h2 id=\"tuples\">Tuples</h2>\n<p>Sometimes it can be useful to have a type that will consist of value pairs. Think of a grid coordinate that has an X and Y value.\nA tuple type can be created in the same way as a normal type, except instead of putting values surrounded by curly brackets <code class=\"language-plaintext highlighter-rouge\">{}</code> after the equals sign <code class=\"language-plaintext highlighter-rouge\">=</code>, you can put types surrounded by parenthesis <code class=\"language-plaintext highlighter-rouge\">()</code>.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">Coordinate</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">)</span> <span class=\"c1\">-- Tuple type for describing an XY coordinate.</span></code></pre>  </figure>\n\n<p>Another example of a tuple is a standard card from a 52 card deck. Each standard card has two values: Suit and Rank. If we wanted to make a standard card type we could write out the 52 values that a card could possibly have, <em>or</em> we could declare three types: Rank, Suit, and then Card which consists of a Rank and Suit pair.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">Rank</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Two</span><span class=\"p\">,</span> <span class=\"kt\">Three</span><span class=\"p\">,</span> <span class=\"kt\">Four</span><span class=\"p\">,</span> <span class=\"kt\">Five</span><span class=\"p\">,</span> <span class=\"kt\">Six</span><span class=\"p\">,</span> <span class=\"kt\">Seven</span><span class=\"p\">,</span> <span class=\"kt\">Eight</span><span class=\"p\">,</span> <span class=\"kt\">Nine</span><span class=\"p\">,</span> <span class=\"kt\">Ten</span><span class=\"p\">,</span> <span class=\"kt\">Jack</span><span class=\"p\">,</span> <span class=\"kt\">Queen</span><span class=\"p\">,</span> <span class=\"kt\">King</span><span class=\"p\">,</span> <span class=\"kt\">Ace</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Suit</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Spade</span><span class=\"p\">,</span> <span class=\"kt\">Heart</span><span class=\"p\">,</span> <span class=\"kt\">Diamond</span><span class=\"p\">,</span> <span class=\"kt\">Club</span><span class=\"p\">}</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Card</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Rank</span><span class=\"p\">,</span> <span class=\"kt\">Suit</span><span class=\"p\">)</span> <span class=\"c1\">-- Tuple type for describing a standard card.</span></code></pre>  </figure>\n\n<p>Tuple types do not have to be only two values (despite how it sounds). Two is just the minimum amount of values a tuple can consist of.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">Card</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Rank</span><span class=\"p\">,</span> <span class=\"kt\">Suit</span><span class=\"p\">)</span> <span class=\"c1\">-- Tuple consisting of two types</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Hand</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">)</span> <span class=\"c1\">-- Tuple type that represents a five card hand. Consists of five Card types.</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">Score</span> <span class=\"o\">=</span> <span class=\"kt\">Int</span> <span class=\"c1\">-- Normal non-tuple type</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Player</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">PlayerColor</span><span class=\"p\">,</span> <span class=\"kt\">Hand</span><span class=\"p\">,</span> <span class=\"kt\">Score</span><span class=\"p\">)</span> <span class=\"c1\">-- Tuple type that represents a player in a card game. Consists of three different types.</span></code></pre>  </figure>\n\n<p><br /></p>\n<h2 id=\"extended-types\">Extended Types</h2>\n<p>Something useful that we can do with types is extend them. An extended type is created by taking an existing type and adding more possible values to it.\nTo create an extended type we must first define the name of the new type (just like creating a normal type), and then set it equal to the type we are extending, followed by an ampersand <code class=\"language-plaintext highlighter-rouge\">&amp;</code> and a new set of possible values surrounded by curly brackets <code class=\"language-plaintext highlighter-rouge\">{}</code>. Below is an example of creating a new extended type (IceCreamFlavor) based off of an existing one (ClassicIceCreamFlavor).</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">ClassicIceCreamFlavor</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Vanilla</span><span class=\"p\">,</span> <span class=\"kt\">Chocolate</span><span class=\"p\">,</span> <span class=\"kt\">Strawberry</span><span class=\"p\">}</span> <span class=\"c1\">-- Regular enumerated type</span></code></pre>  </figure>\n\n<p><img src=\"/imgs/types-ClassicIceCreamFlavor.jpg\" alt=\"ClassicIceCreamFlavor\" /></p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">IceCreamFlavor</span> <span class=\"o\">=</span> <span class=\"kt\">ClassicIceCreamFlavor</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span><span class=\"kt\">Mint</span><span class=\"p\">,</span> <span class=\"kt\">BirthdayCake</span><span class=\"p\">,</span> <span class=\"kt\">BubbleGum</span><span class=\"p\">,</span> <span class=\"kt\">Coffee</span><span class=\"p\">}</span> <span class=\"c1\">-- Extended type</span></code></pre>  </figure>\n\n<p><img src=\"/imgs/types-IceCreamFlavor.jpg\" alt=\"IceCreamFlavor\" />\nSince IceCreamFlavor was created by extending ClassicIceCreamFlavor, its possible values consist of those that were in ClassicIceCreamFlavor (Vanilla, Chocolate, Strawberry) along with the new values that were defined (Mint, BirthdayCake, BubbleGum, Coffee).</p>\n\n<p><br /></p>\n<h4 id=\"example-canasta-card-game\">Example: Canasta Card Game</h4>\n<p>Not all card games use Jokers, but some (like <a href=\"https://en.wikipedia.org/wiki/Canasta\">Canasta</a>) do. We can create a new type that allows for normal cards plus Jokers by extending a previously defined Card type.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">CanastaCard</span> <span class=\"o\">=</span> <span class=\"kt\">Card</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span><span class=\"kt\">Joker</span><span class=\"p\">}</span> <span class=\"c1\">-- Extended type</span></code></pre>  </figure>\n\n<p><br /></p>\n<h4 id=\"example-a-hand-of-cards\">Example: A Hand of Cards</h4>\n<p>The Hand type shown below represents five cards held in a hand. Lets assume the game being played has a five card limit.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">Hand</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">)</span> <span class=\"c1\">-- Tuple type that represents a five card hand. Consists of five Card types.</span></code></pre>  </figure>\n\n<p>What if we wanted the ability to represent not having a card? This could be because a card that was in our hand got played, taken by someone, or discarded. To represent the absence of cards in our hand, we could do something like this:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">MaybeCard</span> <span class=\"o\">=</span> <span class=\"kt\">Card</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span><span class=\"kt\">Nothing</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Hand</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">MaybeCard</span><span class=\"p\">,</span> <span class=\"kt\">MaybeCard</span><span class=\"p\">,</span> <span class=\"kt\">MaybeCard</span><span class=\"p\">,</span> <span class=\"kt\">MaybeCard</span><span class=\"p\">,</span> <span class=\"kt\">MaybeCard</span><span class=\"p\">)</span> <span class=\"c1\">-- Type representing a hand of cards. Consists of five potential cards.</span></code></pre>  </figure>\n\n<p><br /></p>\n<h2 id=\"examples-of-types\">Examples of Types</h2>\n<p>Here are some examples of defining types in BoGL:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"c1\">-- Normal enumerated types</span>\n<span class=\"kr\">type</span> <span class=\"kt\">TossResult</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Heads</span><span class=\"p\">,</span> <span class=\"kt\">Tails</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">CardSuit</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Diamond</span><span class=\"p\">,</span> <span class=\"kt\">Club</span><span class=\"p\">,</span> <span class=\"kt\">Heart</span><span class=\"p\">,</span> <span class=\"kt\">Spade</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">PlayerColor</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Blue</span><span class=\"p\">,</span> <span class=\"kt\">Red</span><span class=\"p\">,</span> <span class=\"kt\">Green</span><span class=\"p\">,</span> <span class=\"kt\">Yellow</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">DiceResult</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">One</span><span class=\"p\">,</span> <span class=\"kt\">Two</span><span class=\"p\">,</span> <span class=\"kt\">Three</span><span class=\"p\">,</span> <span class=\"kt\">Four</span><span class=\"p\">,</span> <span class=\"kt\">Five</span><span class=\"p\">,</span> <span class=\"kt\">Six</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ChessPiece</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Pawn</span><span class=\"p\">,</span> <span class=\"kt\">Bishop</span><span class=\"p\">,</span> <span class=\"kt\">Knight</span><span class=\"p\">,</span> <span class=\"kt\">Rook</span><span class=\"p\">,</span> <span class=\"kt\">Queen</span><span class=\"p\">,</span> <span class=\"kt\">King</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ClueCharacter</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">MissScarlett</span><span class=\"p\">,</span> <span class=\"kt\">ColonelMustard</span><span class=\"p\">,</span> <span class=\"kt\">MrsWhite</span><span class=\"p\">,</span> <span class=\"kt\">ReverendGreen</span><span class=\"p\">,</span> <span class=\"kt\">MrsPeacock</span><span class=\"p\">,</span> <span class=\"kt\">ProfessorPlum</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Rank</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Two</span><span class=\"p\">,</span> <span class=\"kt\">Three</span><span class=\"p\">,</span> <span class=\"kt\">Four</span><span class=\"p\">,</span> <span class=\"kt\">Five</span><span class=\"p\">,</span> <span class=\"kt\">Six</span><span class=\"p\">,</span> <span class=\"kt\">Seven</span><span class=\"p\">,</span> <span class=\"kt\">Eight</span><span class=\"p\">,</span> <span class=\"kt\">Nine</span><span class=\"p\">,</span> <span class=\"kt\">Ten</span><span class=\"p\">,</span> <span class=\"kt\">Jack</span><span class=\"p\">,</span> <span class=\"kt\">Queen</span><span class=\"p\">,</span> <span class=\"kt\">King</span><span class=\"p\">,</span> <span class=\"kt\">Ace</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Suit</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Spade</span><span class=\"p\">,</span> <span class=\"kt\">Heart</span><span class=\"p\">,</span> <span class=\"kt\">Diamond</span><span class=\"p\">,</span> <span class=\"kt\">Club</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ClassicIceCreamFlavor</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Vanilla</span><span class=\"p\">,</span> <span class=\"kt\">Chocolate</span><span class=\"p\">,</span> <span class=\"kt\">Strawberry</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">WaterValveState</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Open</span><span class=\"p\">,</span> <span class=\"kt\">Closed</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">StateOfMatter</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Solid</span><span class=\"p\">,</span> <span class=\"kt\">Liquid</span><span class=\"p\">,</span> <span class=\"kt\">Gas</span><span class=\"p\">,</span> <span class=\"kt\">Plasma</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">ClothingArticle</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Shirt</span><span class=\"p\">,</span> <span class=\"kt\">Pants</span><span class=\"p\">,</span> <span class=\"kt\">Hat</span><span class=\"p\">,</span> <span class=\"kt\">Shoe</span><span class=\"p\">,</span> <span class=\"kt\">Jacket</span><span class=\"p\">,</span> <span class=\"kt\">Scarf</span><span class=\"p\">,</span> <span class=\"kt\">Glove</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">QuestionAnswer</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Yes</span><span class=\"p\">}</span> <span class=\"c1\">-- You are allowed to create a type that has only one possible value.</span>\n\n<span class=\"c1\">-- Types based off of the built in types</span>\n<span class=\"kr\">type</span> <span class=\"kt\">TrueFalseQuestionAnswer</span> <span class=\"o\">=</span> <span class=\"kt\">Bool</span> <span class=\"c1\">-- Possible values are True and False</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Score</span> <span class=\"o\">=</span> <span class=\"kt\">Int</span> <span class=\"c1\">-- Possible values are any integer</span>\n\n<span class=\"c1\">-- Tuple types</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Coordinate</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">)</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Card</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Rank</span><span class=\"p\">,</span> <span class=\"kt\">Suit</span><span class=\"p\">)</span> \n<span class=\"kr\">type</span> <span class=\"kt\">Hand</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">,</span> <span class=\"kt\">Card</span><span class=\"p\">)</span> \n<span class=\"kr\">type</span> <span class=\"kt\">Player</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">PlayerColor</span><span class=\"p\">,</span> <span class=\"kt\">Hand</span><span class=\"p\">,</span> <span class=\"kt\">Score</span><span class=\"p\">)</span> \n\n<span class=\"c1\">-- Extended types</span>\n<span class=\"kr\">type</span> <span class=\"kt\">IceCreamFlavor</span> <span class=\"o\">=</span> <span class=\"kt\">ClassicIceCreamFlavor</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span><span class=\"kt\">Mint</span><span class=\"p\">,</span> <span class=\"kt\">BirthdayCake</span><span class=\"p\">,</span> <span class=\"kt\">BubbleGum</span><span class=\"p\">,</span> <span class=\"kt\">Coffee</span><span class=\"p\">}</span> <span class=\"c1\">-- Extended type</span>\n<span class=\"kr\">type</span> <span class=\"kt\">CanastaCard</span> <span class=\"o\">=</span> <span class=\"kt\">Card</span> <span class=\"o\">&amp;</span> <span class=\"p\">{</span><span class=\"kt\">Joker</span><span class=\"p\">}</span> <span class=\"c1\">-- Extended type</span></code></pre>  </figure>\n\n<p>Here are some of the things you are <span style=\"color:red\"><strong>not allowed</strong></span> to do with types in BoGL:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"n\">pastaSauce</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Alfredo</span><span class=\"p\">,</span> <span class=\"kt\">Marinara</span><span class=\"p\">,</span> <span class=\"kt\">Pesto</span><span class=\"p\">}</span> <span class=\"c1\">-- A type name must start with a capital letter.</span>\n<span class=\"kr\">type</span> <span class=\"kt\">PastaSauce</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">alfredo</span><span class=\"p\">,</span> <span class=\"n\">marinara</span><span class=\"p\">,</span> <span class=\"n\">pesto</span><span class=\"p\">}</span> <span class=\"c1\">-- Value names must start with capital letters.</span>\n<span class=\"kr\">type</span> <span class=\"kt\">EmptyType</span> <span class=\"o\">=</span> <span class=\"p\">{}</span> <span class=\"c1\">-- Every type needs at least one possible value.</span>\n<span class=\"kr\">type</span> <span class=\"kt\">OneValueTuple</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">)</span> <span class=\"c1\">-- Tuples need two or more possible values.</span>\n<span class=\"kr\">type</span> <span class=\"kt\">GamePiece</span> <span class=\"o\">=</span> <span class=\"kt\">ChessPiece</span> <span class=\"o\">&amp;</span> <span class=\"kt\">ClueCharacter</span> <span class=\"c1\">-- Types cannot be extended with types, only sets of possible values.</span></code></pre>  </figure>\n\n<p><a href=\"\">Next, weâ€™ll show you how the program can utilize the TossResult type we created to capture user input!</a></p>\n","dir":"/tutorials/","name":"types.md","path":"tutorials/types.md","url":"/tutorials/types.html"},{"sort":2,"permalink":"tutorials/old/:basename:output_ext","layout":"default","title":"Intro","content":"<h1 id=\"intro\">Intro</h1>\n\n<p><a href=\"GettingStarted\">Previous Tutorial, Getting Started</a></p>\n\n<p>To write your first BoGL Program. Weâ€™re going to give you a few components to work with, we call these bits the <strong>syntax</strong>, or elements of the language. Much like the structure of this sentence that youâ€™re reading now, BoGL has a certain way of talking about things (board games that is).</p>\n\n<p>For starters, the first thing we want to say is what kind of <code class=\"language-plaintext highlighter-rouge\">Game</code> weâ€™re talking about. In this example weâ€™re talking about an Intro, so letâ€™s call is a Demo Game.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>game DemoGame\n</code></pre>  </div></div>\n<p>We need to make sure we write the name of our game altogether without spaces, otherwise BoGL will think weâ€™re talking about something else.</p>\n\n<p>And now weâ€™ve declared a basic kind of game. Maybe we want to give more detail, but just so that we can remember what this means when we look back at it later. We can do this via a comment.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- this is a 'Demo' game, and this is a comment\n-- comments don't do anything in code,\n-- but they can be helpful to describe things you want to remember later on\ngame Demo\n\n{-\n  You can also write comments like this,\n  putting them across multiple lines.\n-}\n</code></pre>  </div></div>\n\n<p>To be specific, every game must begin with the <code class=\"language-plaintext highlighter-rouge\">game</code> keyword, but that doesnâ€™t include comments.</p>\n\n<p>Next, every game must declare the type of the board, this looks kind of like <code class=\"language-plaintext highlighter-rouge\">type Board = Array &lt;size&gt; of &lt;type&gt;</code>, where <size> is a tuple of positive integers, and <type> is the type of pieces that will go on the board.</type></size></p>\n\n<p>Knowing this, if we wanted to created a 10x10 board that held only Integers, we could write our game that like this</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Board = Array (10,10) of Int\n</code></pre>  </div></div>\n\n<p>Now, we also need a way to place pieces on the board. Usually, we need some sort of way to take what you type, and turn it into something that BoGL can use. We can do this by declaring what kind of data we expect to be handling as the <strong>Input</strong> for our program.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Input = Int\n</code></pre>  </div></div>\n\n<p>And all together this looks like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- our 1st demo program\ngame DemoGame\n\n-- declares that our boards for this game\n-- will be 10x10, and will have an Integer\n-- for each space\ntype Board = Array (10,10) of Int\n\n-- indicates we expect Integers to be typed into\n-- our program\ntype Input = Int\n</code></pre>  </div></div>\n\n<p>This is a running example, so congrats on writing your first BoGL program! If you havenâ€™t already you can try it out in our <a href=\"https://bogl.engr.oregonstate.edu/\">online tool</a> to verify everything works as expected. If not take a moment to go back and double check the steps.</p>\n\n<p><a href=\"TheGame\">Next, weâ€™ll show you how to create a simple game</a>.</p>\n","dir":"/tutorials/old/","name":"Intro.md","path":"tutorials/old_tutorials/Intro.md","url":"/tutorials/old/Intro.html"},{"sort":3,"layout":"default","title":"Functions","content":"<h1 id=\"functions\">Functions</h1>\n\n<p>:warning: Make sure that you have a solid understanding of <a href=\"./types\">types</a> before jumping into this tutorial.:warning:</p>\n\n<p>Jack and Rosa want to play a board game. They decide that who gets to go first should be determined by the result of a coin toss.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"n\">game</span> <span class=\"kt\">WhoGoesFirst</span>\n\n<span class=\"kr\">type</span> <span class=\"kt\">TossResult</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Heads</span><span class=\"p\">,</span> <span class=\"kt\">Tails</span><span class=\"p\">}</span>\n<span class=\"kr\">type</span> <span class=\"kt\">Player</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"kt\">Jack</span><span class=\"p\">,</span> <span class=\"kt\">Rosa</span><span class=\"p\">}</span></code></pre>  </figure>\n\n<p>So far we have the name of our game <code class=\"language-plaintext highlighter-rouge\">WhoGoesFirst</code>, a type for capturing a coin toss result <code class=\"language-plaintext highlighter-rouge\">TossResult</code>, and a type that can describe who the first player is <code class=\"language-plaintext highlighter-rouge\">Player</code>. Now we need a way to get an actual TossResult value. Since BoGL is largely a <a href=\"https://en.wikipedia.org/wiki/Functional_programming\">functional language</a> we will do this by creating a <em>function</em> that returns such a value.</p>\n\n<p>Functions inside of BoGL are used to output, or return, some sort of value. The value that is returned from a function is often determined by the inputs provided to the function. \nIf the inputs do not have an effect on the output of a function, then that function will always return the same result. To illustrate this idea, observe the math function below.</p>\n\n<p><strong><em>f(x)</em> = 2</strong></p>\n\n<p>In this function, no matter the value of the parameter <strong>x</strong>, the output (return) of <strong><em>f(x)</em></strong> will always be 2. Below is what this function looks like in BoGL.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Int</span>\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"mi\">2</span></code></pre>  </figure>\n\n<p>To create a function we need to write two things: A declaration and a definition.</p>\n\n<p>The first part of a function is itâ€™s declaration. The declaration is where the types of the functionâ€™s parameters (if there are any) and the type of the functionâ€™s return value are declared. You can write a function declaration by first writing out the functionâ€™s name. Opposite of type names, function names must start with a lowercase letter. In the above example our function is named <em>f</em>. After the name we write a colon <code class=\"language-plaintext highlighter-rouge\">:</code>, which is followed by the parameter types (none in the above example), which are then followed by the output type. The above example takes no parameters, so it only needs its return type of <code class=\"language-plaintext highlighter-rouge\">Int</code> declared.</p>\n\n<p>The second part of a function is its definition. The definition is where all the logic goes that is used to determine the output value. The definition starts with the same function name that was written in the declaration, and then followed by an equals sign <code class=\"language-plaintext highlighter-rouge\">=</code>. After the equals sign is where the logic that determines the output value goes. The code written in the function definition can often span multiple lines.</p>\n\n<p><img src=\"/imgs/functions-no-parameter-function-anatomy.jpg\" alt=\"Anatomy of a parameterless function\" /></p>\n\n<p>To actually utilize this function we must <em>call</em> it. A function that has no parameters can be called by typing itâ€™s name. Try typing <code class=\"language-plaintext highlighter-rouge\">f</code> into the interpreter (right side text box) below and press enter. It should return the value <code class=\"language-plaintext highlighter-rouge\">2</code>.</p>\n\n<!-- <link rel=\"stylesheet\" href=\"embed_test.css\"/> -->\n<script src=\"/assets/js/embed_test.js\"></script>\n\n<!--The embedded editor START-->\n<div class=\"bogl-embed-editor\">\n <div class=\"bogl\"></div>\n <div class=\"left bogl-code\" contenteditable=\"true\">\n\t \n\t \t\ngame FunctionDemo <br />\n<br />\nf : Int<br />\nf = 2<br />\n\n\t \n\n </div>\n <div class=\"right\">\n <div class=\"bogl-repl-result\"></div>\n <input class=\"bogl-repl-run\" placeholder=\"&gt;\" type=\"text\" />\n </div>\n</div>\n<p><br />\n<!--END--></p>\n\n<p>Now that we know how to create a basic function that returns a value, lets go over how to make a function that takes a parameter. We will start with another math function as an example.</p>\n\n<p><strong><em>f(x)</em> = 2x</strong></p>\n\n<p>If we were to assign our parameter, <strong>x</strong>, the value of 3, then the value of <strong><em>f(x)</em></strong> would be 6. This function takes in a value for <strong>x</strong> and uses that to compute a value for <strong><em>f(x)</em></strong>, which in this case is <strong>x</strong> multiplied by two. We can also write this function in BoGL.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">Int</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Int</span>\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">x</span></code></pre>  </figure>\n\n<p><img src=\"/imgs/functions-function-with-parameter-anatomy.jpg\" alt=\"function with parameter anatomy\" /></p>\n\n<p>Since there is now a parameter that influences the output of the function, it must be accounted for in the function declaration. Parameters are written before the output value and are always followed by an arrow <code class=\"language-plaintext highlighter-rouge\">-&gt;</code>. Reading the above function declaration for the function <em>f</em> we know that it takes an integer type value as itâ€™s parameter and returns a integer type value.\nThe output value <code class=\"language-plaintext highlighter-rouge\">2 * x</code> is what we call an <a href=\"https://en.wikipedia.org/wiki/Expression_%28computer_science%29\">expression</a>. An expression is something that must be evaluated (like calculating 2 * 2) before itâ€™s value is determined. A function returns the result of evaluating an expression. We will cover expressions in detail in the next tutorial. For now lets utilize what we have learned so far to make a function that takes a coin toss result as an input and outputs a first player.</p>\n\n<p>We will call this function <em>determineFirstPlayer</em>. It will take a <em>TossResult</em> as a parameter and return a <em>Player</em>. Here is itâ€™s function declaration:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"n\">determineFirstPlayer</span> <span class=\"o\">:</span> <span class=\"kt\">TossResult</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Player</span></code></pre>  </figure>\n\n<p>Next we will define itâ€™s return value. For now we will define the return value to be <em>Rosa</em>.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"n\">determineFirstPlayer</span> <span class=\"o\">=</span> <span class=\"kt\">Rosa</span></code></pre>  </figure>\n\n<p>Together it will look like:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"n\">determineFirstPlayer</span> <span class=\"o\">:</span> <span class=\"kt\">TossResult</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Player</span>\n<span class=\"n\">determineFirstPlayer</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"kt\">Rosa</span></code></pre>  </figure>\n\n<p>To call a function that has a parameter you must first type the functionâ€™s name, followed by parenthesis <code class=\"language-plaintext highlighter-rouge\">()</code>. Inside of those parenthesis you must put a value that matches the type of the functionâ€™s parameter. The function call <code class=\"language-plaintext highlighter-rouge\">determineFirstPlayer(Heads)</code> will return the value <code class=\"language-plaintext highlighter-rouge\">Rosa</code>.</p>\n\n<p>You may notice that the <em>result</em> parameter is not being utilized, and that the output of this function will always be <em>Rosa</em>, no matter if the <em>result</em> is Heads or Tails. In the next tutorial we will look at how we can replace the value <em>Rosa</em> with an expression that can evaluate to <em>Jack</em> or <em>Rosa</em> depending on the parameter <em>result</em>â€™s value.</p>\n\n<p><br /></p>\n<h2 id=\"functions-with-multiple-parameters\">Functions with Multiple Parameters</h2>\n<p>A function can have multiple parameters by using <a href=\"./types.html#tuples\">tuples</a>. The function shown below takes two numbers and returns the result of adding them together.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Int</span>\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span></code></pre>  </figure>\n\n<p>The amount of parameters is dependent on the amount of types held in the functionâ€™s tuple parameter type.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"c1\">-- The function below adds six numbers together.</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Int</span>\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">e</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span> <span class=\"o\">+</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">d</span> <span class=\"o\">+</span> <span class=\"n\">e</span> <span class=\"o\">+</span> <span class=\"n\">f</span></code></pre>  </figure>\n\n<p>You still need to specify parameter names when using a previously defined tuple.</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-haskell\" data-lang=\"haskell\"><span class=\"kr\">type</span> <span class=\"kt\">NumPair</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">Int</span><span class=\"p\">,</span> <span class=\"kt\">Int</span><span class=\"p\">)</span>\n\n<span class=\"c1\">-- The function below adds the two numbers inside of a NumPair together.</span>\n<span class=\"n\">f</span> <span class=\"o\">:</span> <span class=\"kt\">NumPair</span> <span class=\"o\">-&gt;</span> <span class=\"kt\">Int</span>\n<span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span><span class=\"p\">;</span> <span class=\"c1\">-- Still need to specify parameter names a and b </span></code></pre>  </figure>\n\n","dir":"/tutorials/","name":"functions.md","path":"tutorials/functions.md","url":"/tutorials/functions.html"},{"sort":3,"permalink":"tutorials/old/:basename:output_ext","layout":"default","title":"The (Simple) Game","content":"<h1 id=\"the-simple-game\">The (Simple) Game</h1>\n\n<p><a href=\"Intro\">Previous Tutorial, Intro</a></p>\n\n<p>In this tutorial, we will walk through how to create a basic game that end as soon as it starts, called â€˜The Gameâ€™. This will demonstrate that we can describe a game even if it doesnâ€™t do very much. If you havenâ€™t already, we would highly recommend you go over the tutorials before this one, so you will be familiar with some of the concepts weâ€™ll be using.</p>\n\n<p>First, weâ€™ll create a new game called TheGame</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>game TheGame\n</code></pre>  </div></div>\n\n<p>Even though we donâ€™t plan on doing much in this game, we still are required to define the <strong>Board</strong> and <strong>Input</strong> types for this game. First, weâ€™ll define a simple 1x1 board (a single space), but this time weâ€™ll make it store Bool!</p>\n\n<p>Bool may seem unfamiliar at first, at itâ€™s an odd name when you think about it. However, itâ€™s used to represent the basic of concept of something you are quite familiar with (hopefully!), True and False. Thatâ€™s it! If weâ€™re talking about a Bool (or a Boolean) weâ€™re talking about something that can be either True or False. So, this board can have only 1 of 2 possible values in this one space, a value of True, or a value of False.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Board = Array(1,1) of Bool\n</code></pre>  </div></div>\n\n<p>Now, if youâ€™re thinking ahead, you might wondering how we will be able to read something that will be a <strong>Bool</strong> that we can use on the board. Although we wonâ€™t be reading anything just yet, BoGL requires us to declare what type of <strong>Input</strong> we will be expecting. In this case, we can simply say it should match what we have on our board, a Bool.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Input = Bool\n</code></pre>  </div></div>\n\n<p>Now, weâ€™ve been working with a few types so far, Bool, Int, and Board. These all are ways of allowing us to represent things in BoGL. Int for positive whole numbers, Bool for True and False, and a Board to represent what size of game board weâ€™re working with and what we can â€˜putâ€™ on it.</p>\n\n<p>However, we can introduce what we call <em>type synonyms</em> as well. These are used to help us describe things we want that can categorized, such as to describe the idea of a <strong>Result</strong> in a game. We know there is such a thing as <strong>Winning</strong> and <strong>Losing</strong>, so is there a way to express this in BoGL without using Bool, Int, or something else? It turns out there is, and we can do just that like this:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- type synonym called Result\n-- describes the notions of winning as 'YouWin' and losing as 'YouLose'\ntype Result = {YouWin,YouLose}\n</code></pre>  </div></div>\n<p>And there we go! Just like that weâ€™ve used what are called <strong>Symbols</strong> to express what the ideas of winning and losing are. We have a symbol to represent each idea of what a <strong>Result</strong> could be. If we wanted, we could even add another symbol for a tie, like so:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- adds a symbol to describe a result\n-- that is a tie\ntype Result = {YouWin,YouLose,ItsATie}\n</code></pre>  </div></div>\n<p>Notice that just like the name of our game, BoGL likes the things we are describing to be all in one word.</p>\n\n<p>With what we have written out so far, we can write a way to play this game. Since playing is an action, we can describe it as a routine or a procedure, i.e. something that we do. In Computer Science, we commonly refer to this as a <em>function</em>, which is very much a routine or procedure that does something. For our game, we want to define a function for playing our game, and since this is a simple game weâ€™re going to say the result is we win every time.</p>\n\n<p>To start writing this we need to write a <strong>declaration</strong> for our function, something that states the name and what it returns. It also can say what it takes, but weâ€™ll save that for the next lesson. Our function will be called <code class=\"language-plaintext highlighter-rouge\">play</code>, and it will return something that should be a <code class=\"language-plaintext highlighter-rouge\">Result</code>, so the 1st part will look like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>play : Result\n</code></pre>  </div></div>\n<p>Great, now that weâ€™ve <em>declared</em> what itâ€™s called, and what it does (gives us a result), we need to <em>define</em> how it does this. We can do this by writing in what we call a <strong>definition</strong>. In this case, our function can do this by simply winning, so we can say that playing is essentially just winning this game; and we can say that like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>play = YouWin\n</code></pre>  </div></div>\n\n<p>And thatâ€™s our play function, together it should look like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>play : Result\nplay = YouWin\n</code></pre>  </div></div>\n\n<p>And now, with the rest of our code, we have:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- our simple game that we always win\ngame TheGame\n\n-- has a 1x1 board that has either True or False\ntype Board = Array(1,1) of Bool\n\n-- and we're expecting True or False from the user\ntype Input = Bool\n\n-- describes the idea of what results our game can have\ntype Result = {YouWin,YouLose,ItsATie}\n\n-- and finally, a function that describes the procedure/routine for\n-- playing this game\nplay : Result\nplay = YouWin\n</code></pre>  </div></div>\n\n<p>You can type this code into the editor, run it by typing <code class=\"language-plaintext highlighter-rouge\">play</code>, and you should get the result back of â€˜YouWinâ€™. If so, congrats, you have completed this tutorial! Take a moment to think about what weâ€™ve gone over here.</p>\n\n<p>When youâ€™re ready, <a href=\"Function\">our next tutorial is all about writing functions</a>.</p>\n","dir":"/tutorials/old/","name":"TheGame.md","path":"tutorials/old_tutorials/TheGame.md","url":"/tutorials/old/TheGame.html"},{"sort":4,"permalink":"tutorials/old/:basename:output_ext","layout":"default","title":"In a Row","content":"<h1 id=\"in-a-row\">In a Row</h1>\n\n<p><a href=\"Input\">Previous Tutorial, Input</a>.</p>\n\n<p>In this tutorial weâ€™ll talk about how to describe something closer to an actual board game. In this case, weâ€™ll talk about how to write up something that is similar to Tic Tac Toe, except with just one player.</p>\n\n<p>Alright, so jumping right into it weâ€™ll create a game thatâ€™s called <code class=\"language-plaintext highlighter-rouge\">InARow</code>, and the <strong>Board</strong> and <strong>Input</strong> types will be a bit different than in our prior examples. What weâ€™re going to do is setup a game much like Tic Tac Toe, or Connect 4. In our version, weâ€™re going to end when there are 3 pieces that are in a row anywhere on our board. Weâ€™ll say this counts for pieces that are in a row horizontally, vertically, or diagonally, and weâ€™ll just describe these all as being in a row. Also, weâ€™re going to say this is a 1 player game, not very challenging for that one player, but it will certainly be a bit easier for us to set this up then.</p>\n\n<p>For starters, weâ€™ll be needing a 3x3 board, and to express that we can use <code class=\"language-plaintext highlighter-rouge\">Array(3,3)</code>. Now for every space we have to think about what we want to have there. Before, we had Boards of <strong>Int</strong> and <strong>Bool</strong>, and that could work for this (for example, a space with a 1 or True has a piece on it, and 0 or False doesnâ€™t have a piece on it), but letâ€™s try something else. Both of these ways could let us describe how a space on the board is either occupied by a player or is empty, however thereâ€™s another way we can go about this. First, letâ€™s write up our player type.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- a type of Player, which describes the only kind of player we can have in the game\ntype Player = {OnlyPlayer}\n</code></pre>  </div></div>\n<p>Now this lets us describe the idea of what kinds of Players we have (only one in this case), but what about if we the case where no player is on a space? Surely we could write something like this and it would work right?</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- player and 'no' player\ntype Player = {OnlyPlayer,NoPlayer}\n</code></pre>  </div></div>\n<p>Well, this <em>could</em> work, but the problem is that <code class=\"language-plaintext highlighter-rouge\">NoPlayer</code> <em>isnâ€™t really a player</em>. Itâ€™s more like describing the absence of a player, and if our <code class=\"language-plaintext highlighter-rouge\">Player</code> type describes that players we can have, maybe we need another way to describe what <em>else</em> we can have besides a player.</p>\n\n<p>Thereâ€™s a handy way we can do, and we do so right in the type of our board game as follows.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- a 5x5 board where each space is occupied\n-- by a value of type Player `and` Empty\ntype Board = Array(3,3) of Player &amp; {Empty}\n</code></pre>  </div></div>\n<p>This is much like what we wrote before, but whatâ€™s up with the <code class=\"language-plaintext highlighter-rouge\">Player &amp; {Empty}</code> thing? Well, letâ€™s break it down.</p>\n\n<p>First, the <code class=\"language-plaintext highlighter-rouge\">Player</code> part seem familiar. We can have a <code class=\"language-plaintext highlighter-rouge\">Player</code> on any space of the Board. However, this new addition of <code class=\"language-plaintext highlighter-rouge\">&amp; {Empty}</code> seems a bit odd. The way we could describe this, along with player, is a type of <em>Player and Empty</em>. This is akin to a union in set theory, and matches up nicely with any pre-existing knowledge you may have in this area. If this isnâ€™t too familiar thatâ€™s okay, you can think of <code class=\"language-plaintext highlighter-rouge\">Player &amp; {Empty}</code> as taking the type of <code class=\"language-plaintext highlighter-rouge\">Player</code>, and extending it a bit to also include the value of <code class=\"language-plaintext highlighter-rouge\">Empty</code>. We could have modified our Player type directly to include <code class=\"language-plaintext highlighter-rouge\">{OnlyPlayer,Empty}</code>, but again the absence of a player is <em>not actually a player</em>, so we want to keep that separate.</p>\n\n<p>As a side note, we can extend by more than one value of another type, but we cannot extend by types themselves. That means something like <code class=\"language-plaintext highlighter-rouge\">Int &amp; {Bool}</code> is not technically correct, but <code class=\"language-plaintext highlighter-rouge\">Int &amp; {A1,A2,A3}</code> is.</p>\n\n<p>In addition, weâ€™ll want to take a type of <code class=\"language-plaintext highlighter-rouge\">Input</code> that is a position, since we will only be placing <code class=\"language-plaintext highlighter-rouge\">OnlyPlayer</code> values. To take in a position, we could write something like <code class=\"language-plaintext highlighter-rouge\">type Input = Int</code>, and run something like the <code class=\"language-plaintext highlighter-rouge\">let</code> expressions we used in the previous <a href=\"Input\">Input</a> tutorial. But we can do a bit better than that, and since we know we want both an X and a Y, we can take them both at once like this.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Input = (Int,Int)\n</code></pre>  </div></div>\n\n<p>This means our <code class=\"language-plaintext highlighter-rouge\">Input</code> type is synonymous with a pair of integers (formally called a tuple of Int, Int). This lets us take inputs in the form of <code class=\"language-plaintext highlighter-rouge\">(1,2)</code>, with the first number being the column, and the second number being the row. We should keep in mind that we have to type it in this format as well, so <code class=\"language-plaintext highlighter-rouge\">1,3</code> or <code class=\"language-plaintext highlighter-rouge\">(2 3)</code> <em>wonâ€™t work</em>, we have to type it in the <code class=\"language-plaintext highlighter-rouge\">(x,y)</code> format.</p>\n\n<p>So, with what we have so far, we have a 5x5 board of either <code class=\"language-plaintext highlighter-rouge\">OnlyPlayer</code> or <code class=\"language-plaintext highlighter-rouge\">Empty</code> for each space, which makes sense for what weâ€™re trying to do.</p>\n\n<p>Next, we want to setup another board equation for the board weâ€™re going to use in this game. If youâ€™re not familiar with board equations (or if you feel a bit rusty) you can go back and check on the <a href=\"Input\">last tutorial about input</a>. In our game here, weâ€™ll call our Board <code class=\"language-plaintext highlighter-rouge\">board</code>, and although these are close they are distinct (the lower-case â€˜bâ€™ is enough to distinguish them, otherwise BoGL wouldnâ€™t allow this!).</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- declare a board with all spaces being Empty at the start\nboard : Board\n-- for all 'x' and all 'y', set (x,y) to Empty\nboard!(x,y) = Empty\n</code></pre>  </div></div>\n\n<p>Now we have a board of type <code class=\"language-plaintext highlighter-rouge\">Board</code> (remember, the casing is important!), that is full of Empty spaces, or the absence of a Player. This produces a board that would look like the following.</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Empty Empty Empty\nEmpty Empty Empty\nEmpty Empty Empty\n</code></pre>  </div></div>\n\n<p>Additionally, we can add another line to our board like so:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>board : Board\nboard!(x,y) = Empty\n-- for all 'x', set (x,1) to 'OnlyPlayer'\nboard!(x,1) = OnlyPlayer\n</code></pre>  </div></div>\n\n<p>This is completely valid. We can write additional â€˜board equationsâ€™ on each line using the name of â€˜boardâ€™ to keep changing how our board looks, so now it is:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>OnlyPlayer OnlyPlayer OnlyPlayer\nEmpty      Empty      Empty\nEmpty      Empty      Empty\n</code></pre>  </div></div>\n<p>Each entry has been spaced out a bit to make it easier to read, but you can see every column of the first row now has a value of <code class=\"language-plaintext highlighter-rouge\">OnlyPlayer</code>. You can play around with this, but we will want to keep all spaces as <code class=\"language-plaintext highlighter-rouge\">Empty</code> for the rest of our example.</p>\n\n<p>Now, onto the <code class=\"language-plaintext highlighter-rouge\">inARow</code> function. This is one of many builtin functions that is already written for you, and can be used in any of your BoGL programs. This one takes 3 parameters:</p>\n<ol>\n <li>The number of values to check as a row (such as 3 in a row, 4 in a row, etc.)</li>\n <li>The value to check for (<code class=\"language-plaintext highlighter-rouge\">X</code>, <code class=\"language-plaintext highlighter-rouge\">Y</code>, <code class=\"language-plaintext highlighter-rouge\">OnlyPlayer</code>, etc.)</li>\n <li>The board to check</li>\n</ol>\n\n<p>So now letâ€™s try this out in the Interpreter, if you type in: <code class=\"language-plaintext highlighter-rouge\">inARow(3,OnlyPlayer,board)</code>, what do you think youâ€™ll get?</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt; inARow(3,OnlyPlayer,board)\n\nTrue\n</code></pre>  </div></div>\n\n<p>Nice! But what if we try 4 in a row?</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt; inARow(4,OnlyPlayer,board)\n\nFalse\n</code></pre>  </div></div>\n\n<p>Makes sense right? This function can come in handy when youâ€™re trying to describe board games, and in particular can be helpful when youâ€™re trying to describe a way to end a game.</p>\n\n<p>To do this, we need to introduce one more idea, <code class=\"language-plaintext highlighter-rouge\">while</code>. If youâ€™ve seen other programming languages before, this may be familiar to you already, but if not donâ€™t worry, itâ€™s not too bad to describe.</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">while</code> is a keyword in our language that means the next thing you write should be an expression that gives a value of either <code class=\"language-plaintext highlighter-rouge\">True</code> or <code class=\"language-plaintext highlighter-rouge\">False</code>.</p>\n\n<p>Hereâ€™s a quick example of <code class=\"language-plaintext highlighter-rouge\">while</code>, using a function weâ€™ll write called <code class=\"language-plaintext highlighter-rouge\">loop</code>. This function takes an <code class=\"language-plaintext highlighter-rouge\">Int</code> and returns an <code class=\"language-plaintext highlighter-rouge\">Int</code>. The <code class=\"language-plaintext highlighter-rouge\">Int</code> it takes is called <code class=\"language-plaintext highlighter-rouge\">x</code>, and while that x is less than 10, â€˜doâ€™ x + 1, and re-evaluate the loop again with our new <code class=\"language-plaintext highlighter-rouge\">Int</code>. In this case, the new int will be our new <code class=\"language-plaintext highlighter-rouge\">x</code>, and we can repeat this process until <code class=\"language-plaintext highlighter-rouge\">x &lt; 10</code> results in false.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>loop : Int -&gt; Int\nloop(x) = while x &lt; 10 do x+1\n</code></pre>  </div></div>\n<p>Running this in the interpreter as <code class=\"language-plaintext highlighter-rouge\">loop(1)</code> will give us <code class=\"language-plaintext highlighter-rouge\">10</code>, and so will any number passed into loop that is up to 10. However, once we start passing numbers larger than 10, we will get back the exact number we pass in. This is because instead of â€˜doingâ€™ the <code class=\"language-plaintext highlighter-rouge\">x+1</code>, we do nothing and return what we were given.</p>\n\n<p>There is, of course, a practical limit, eventually if you type in numbers large enough youâ€™ll start getting back weird numbers, like <br />23982394829482394<br />giving us back<br />23982394829482390<br />\nWhatâ€™s up with that?</p>\n\n<p>Well, it turns out thereâ€™s a practical limit to how large a number you can type into your browser, because it starts to cull off the extra part of the number it canâ€™t store. If you encounter this (or a student you are teaching), itâ€™s perfectly normal, but just donâ€™t try to compute any number <em>too</em> big, this is just a teaching language after all; and it will do itâ€™s best to represent what you give it.</p>\n\n<p>Okay, so we have a general idea of while with numbers. How can we use this to play a game?</p>\n\n<p>What we can do is to swap out <code class=\"language-plaintext highlighter-rouge\">x &lt; 10</code> for <code class=\"language-plaintext highlighter-rouge\">inARow(3,OnlyPlayer,board)</code>, and to swap out <code class=\"language-plaintext highlighter-rouge\">x+1</code> for some way to place pieces on the boardâ€¦hmmmâ€¦and it turns out we have a very handy <code class=\"language-plaintext highlighter-rouge\">Input</code> type of <code class=\"language-plaintext highlighter-rouge\">(Int,Int)</code>, so we can enter in positions like <code class=\"language-plaintext highlighter-rouge\">(1,1)</code>, or <code class=\"language-plaintext highlighter-rouge\">(2,2)</code>.</p>\n\n<p>We can us this to place pieces on our board, and since our input is of type <code class=\"language-plaintext highlighter-rouge\">Player</code>, we can write this altogether as:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>play : Board -&gt; Board\nplay(b) = while not(inARow(3,OnlyPlayer,b)) do place(OnlyPlayer,b,input)\n</code></pre>  </div></div>\n\n<p>I snuck in a few new concepts, but weâ€™ll break them down here.</p>\n\n<p>First the <code class=\"language-plaintext highlighter-rouge\">not</code> function that takes a Bool, and returns itâ€™s negation, (i.e True becomes False, and vice-versa). We pass in the expression for whether we have 3 <code class=\"language-plaintext highlighter-rouge\">OnlyPlayer</code> values in a row, which will be a Bool. This allows us to loop while we <em>do not have 3 in a row</em>.</p>\n\n<p>Secondly, <code class=\"language-plaintext highlighter-rouge\">place(OnlyPlayer,b,input)</code>, is a combination of 4 different things.</p>\n<ol>\n <li>Another builtin function called <code class=\"language-plaintext highlighter-rouge\">place</code>, which takes a value to place, a board to place that value on, and a position to place that value at (specicially of (Int,Int)). The result of this function is an updated board with the new piece placed at the given position.</li>\n <li><code class=\"language-plaintext highlighter-rouge\">OnlyPlayer</code> being the sole value we will be placing at any space.</li>\n <li><code class=\"language-plaintext highlighter-rouge\">b</code> being the board we will be placing pieces at.</li>\n <li>The builtin <code class=\"language-plaintext highlighter-rouge\">input</code> function, which if we have the type of <code class=\"language-plaintext highlighter-rouge\">Input</code> set to <code class=\"language-plaintext highlighter-rouge\">(Int,Int)</code> perfectly fills this last argument requirement.</li>\n</ol>\n\n<p>Collectivelly, our resulting program should look something like this, but again itâ€™s perfectly fine if yours looks a bit different!</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- A game of just 'in a row'\n-- once you get 3 in a row, we're done!\n\ngame InARow\n\n\ntype Board = Array(3,3) of Player &amp; {Empty}\ntype Input = (Int,Int)\n\nboard : Board\nboard!(x,y) = Empty\n\nplay : Board -&gt; Board\nplay(b) = while not(inARow(3,OnlyPlayer,b)) do place(OnlyPlayer,b,input)\n</code></pre>  </div></div>\n\n<p>Now playing this game can be done by running <code class=\"language-plaintext highlighter-rouge\">play(board)</code> in the Interpreter. Upon doing this weâ€™ll see that BoGL is asking for us to enter input, and we can start putting values on our board. An example of playing this out might look like so:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>&gt; play(board)\n\n\n ðŸ¤– BoGL Says: Enter input, or \"clear\" to stop.\n\n&gt; (1,1)\n\nOnlyPlayer\tEmpty\tEmpty\nEmpty\tEmpty\tEmpty\nEmpty\tEmpty\tEmpty\n\n&gt; (1,2)\n\nOnlyPlayer\tEmpty\tEmpty\nOnlyPlayer\tEmpty\tEmpty\nEmpty\tEmpty\tEmpty\n\n&gt; (1,3)\n\nOnlyPlayer\tEmpty\tEmpty\nOnlyPlayer\tEmpty\tEmpty\nOnlyPlayer\tEmpty\tEmpty\n\n ðŸ¤– BoGL Says: Done reading input.\n\n</code></pre>  </div></div>\n<p>After we see <code class=\"language-plaintext highlighter-rouge\">Done reading input.</code> weâ€™re all done, and our game has finished! Try out your own example to make sure it works as expected, and if it does then congratulations! The next step would be getting this working for two players, but thatâ€™s something we will cover in our last tutorial coming up.</p>\n\n<p><a href=\"BoardCount\">Next, Counting Pieces of Board</a>.</p>\n","dir":"/tutorials/old/","name":"InARow.md","path":"tutorials/old_tutorials/InARow.md","url":"/tutorials/old/InARow.html"},{"sort":4,"layout":"default","title":"Expressions","content":"<h1 id=\"expressions\">Expressions</h1>\n\n<p>:construction: Under construction :construction:</p>\n","dir":"/tutorials/","name":"expressions.md","path":"tutorials/expressions.md","url":"/tutorials/expressions.html"},{"sort":4,"permalink":"tutorials/old/:basename:output_ext","layout":"default","title":"Your Second Function","content":"<h1 id=\"your-second-function\">Your Second Function</h1>\n\n<p><a href=\"TheGame\">Previous Tutorial, The Game</a></p>\n\n<p>After finishing your last tutorial, youâ€™re probably wondering a little bit more about some of the aspects of this language. One of the next things we would like to go over in this tutorial is <strong>Functions</strong>. As we mentioned before, you can think of functions as a way of describing a process or routine that you would do. This is comparable to what you do every morning when you wake up, such as brushing your teeth, eating breakfast, going to school (but maybe not on the weekendsâ€¦). These are things that you do repeatedly, and pretty much the same way each time. Similarly, you can think of functions as something that is repeated roughly the same way every time you use it.</p>\n\n<p>Keeping with our focus on board games, something that can be described in a function is the idea of taking a turn. Every turn a player does something, and at the end of their turn the next player goes, and this repeats until the game ends. In this tutorial weâ€™re going to explore another simple game where we 1 turn happens, and the second player will win. Maybe not so much fun for the first player, but itâ€™ll help us grasp a bit more of BoGL.</p>\n\n<p>First, letâ€™s setup a game called OneTurn, which describes what kind of game weâ€™re going to setup nicely:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>game OneTurn\n</code></pre>  </div></div>\n\n<p>Again, since we donâ€™t need to worry about the board yet we can keep it simple like before:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Board = Array(1,1) of Bool\n</code></pre>  </div></div>\n<p>And, we want to match our Input to what weâ€™re expecting to take in for our Board</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Input = Bool\n</code></pre>  </div></div>\n<p>Great! Now we also can use the basis of our type synonym from before, a.k.a the concept of different kinds of results for our game. However, we want to change it a bit, instead of just winning and losing, we want to clarify <em>who</em> wins or loses. We can do this by saying itâ€™s either player 1, or player 2.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Result = {P1Wins,P2Wins}\n</code></pre>  </div></div>\n<p>Based on who won, we can also tell who lost, so we get some extra information for free here.</p>\n\n<p>Now weâ€™re going to introduce another type synonym, but this one will be used to describe the idea of players in our game. We probably want to call this type synonym <code class=\"language-plaintext highlighter-rouge\">Player</code> to make sure that lines up with what we are talking about. Now the idea of what symbols we use to describe these players is kind of up to you. In our example, weâ€™ll go with <code class=\"language-plaintext highlighter-rouge\">P1</code> and <code class=\"language-plaintext highlighter-rouge\">P2</code>, but you could certainly go with <code class=\"language-plaintext highlighter-rouge\">A</code> and <code class=\"language-plaintext highlighter-rouge\">B</code>, <code class=\"language-plaintext highlighter-rouge\">X</code> and <code class=\"language-plaintext highlighter-rouge\">O</code>, or something of your own design, get creative if you want!</p>\n\n<p>For ours weâ€™ll write:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- a type synonym called 'Player'\n-- and it can be described with two\n-- symbols P1 and P2, representing the 1st\n-- and 2nd player in our game\ntype Player = {P1,P2}\n</code></pre>  </div></div>\n\n<p>Finally weâ€™re at the function. Like before, weâ€™ll want to determine what the <em>declaration</em> looks like. Letâ€™s say weâ€™ll call it <code class=\"language-plaintext highlighter-rouge\">play</code> like before, but now we have to think about what it will do overall. We know that we have 2 players in our game, and 2 results, and we would like to connect these somehow. If P1 goes first, then we would like P2 to win, and the opposite if P2 goes first. This actually tells us what we would like to write in, specifically for a <code class=\"language-plaintext highlighter-rouge\">Player</code> we can get a <code class=\"language-plaintext highlighter-rouge\">Result</code>. We can detail that for our play function in BoGL by writing the following:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- play is a function that represents\n-- that this will go from a Player to a Result\nplay : Player -&gt; Result\n</code></pre>  </div></div>\n\n<p>The next part can be a bit tricky, but the first part we can write is going to use something we call a <strong>parameter</strong>. A parameter (or a variable), allows us to use a letter or a word to represent a particular â€˜thingâ€™. In this case, weâ€™re interested in using our parameter to represent which particular Player weâ€™re working with. This will look like <code class=\"language-plaintext highlighter-rouge\">play(p) =</code>, where <code class=\"language-plaintext highlighter-rouge\">p</code> is going to represent whatever player weâ€™re going to use to generate our result.</p>\n\n<p>With our Player we can say something like â€œIf p represents P1, then we want P2 to Winâ€. We also want to say â€œIf p represents P2, then we want to P1 to Winâ€. To make things a little more succinct, we can combine them, and say â€œIf p represents P1, then we want P2 to Win, <em>otherwise</em> P1 Winsâ€. Now this is actually quite close to what we want to write in our code, so Iâ€™ll put it out side-by-side with some slight adjustment so we can compare:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>if p is the same as P1, then P2 Wins, else P1 Wins\n</code></pre>  </div></div>\n<p>And in codeâ€¦</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>if p == P1 then P2Wins else P1Wins\n</code></pre>  </div></div>\n<p>So weâ€™ve replaced <code class=\"language-plaintext highlighter-rouge\">is the same as</code> with <code class=\"language-plaintext highlighter-rouge\">==</code>, weâ€™ve removed the commas, and weâ€™ve combined the words P1 and P2 with Wins so that they match our symbols from before. This expresses the idea that if P1 goes first, then P2 wins, otherwise P1 wins, not so bad once you walk through it a bit!</p>\n\n<p>Putting this together with the parts we wrote earlier, our complete function looks like this:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>play : Player -&gt; Result\nplay(p) = if p == P1 then P2Wins else P1Wins\n</code></pre>  </div></div>\n\n<p>All together our game description looks like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>game OneTurn\n\ntype Board = Array(1,1) of Bool\ntype Input = Bool\ntype Result = {P1Wins,P2Wins}\n\n-- describes our players\ntype Player = {P1,P2}\n\n-- describes a procedure of playing\n-- a game where the player who goes second always wins\nplay : Player -&gt; Result\nplay(p) = if p == P1 then P2Wins else P1Wins\n</code></pre>  </div></div>\n\n<p>And thatâ€™s it! If you havenâ€™t run this already be sure to try this on the <a href=\"https://bogl.engr.oregonstate.edu/\">online tool</a> to verify everything is okay so far.</p>\n\n<p>The last step is running our function, which like before is just a matter of typing out the name of the function, but now we need to add which player will go into our parameter as well. When weâ€™re calling (another way of saying to do what the function does) functions we need to use <code class=\"language-plaintext highlighter-rouge\">()</code>, and we need to pass our parameter inside the parentheses. Calling play in our code will take one of the player symbols, so we can do:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>play(P1)\n</code></pre>  </div></div>\n<p>Or we could do <code class=\"language-plaintext highlighter-rouge\">P2</code> if we wanted. But whichever player we pick, we should see the other one win. If so then youâ€™ve finished this tutorial! As always take a moment to go back over the concepts and think about what youâ€™ve picked up so far.</p>\n\n<p><a href=\"Input\">Next, weâ€™ll talk about taking input into our programs.</a></p>\n","dir":"/tutorials/old/","name":"Function.md","path":"tutorials/old_tutorials/Function.md","url":"/tutorials/old/Function.html"},{"sort":5,"permalink":"tutorials/old/:basename:output_ext","layout":"default","title":"Input","content":"<h1 id=\"input\">Input</h1>\n\n<p><a href=\"Function\">Previous Tutorial, Your Second Function</a>.</p>\n\n<p>For this tutorial weâ€™ll go over how to handle input into a program. If youâ€™ve been following along with the tutorials up until this point you should have a little bit of working code from before. If you donâ€™t have your code, or you are starting for the first time, you can look back at the previous tutorials to make sure you understand everything that weâ€™re using here.</p>\n\n<p>Based on what we wrote in our last tutorial, weâ€™re going to take that game and extend it a little bit. In this case weâ€™ll be using input from you (the user) to determine who will be winning this game.</p>\n\n<p>First off weâ€™re going to call this <code class=\"language-plaintext highlighter-rouge\">game OneTurn2</code>, since itâ€™s going to be our second version of our <code class=\"language-plaintext highlighter-rouge\">OneTurn</code> game from before.</p>\n\n<p>Also like before, weâ€™re okay with keeping our board simple, since we wonâ€™t be using it. We can setup something like before:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Board = Array(2,2) of Bool\n</code></pre>  </div></div>\n\n<p>Now for our input, weâ€™re going to clarify that instead of Bool like we wrote for the Board, weâ€™re going to expect Integers as input.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Input = Int\n</code></pre>  </div></div>\n\n<p>Also, like before, weâ€™re going to declare a type synonym to represent the two players that will be participating in this game</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Player = {P1,P2}\n</code></pre>  </div></div>\n\n<p>We want to add in a type synonym for the result of our game too.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>type Result = {P1Wins, P2Wins}\n</code></pre>  </div></div>\n\n<p>Next we want to define what we call a <em>board equation</em>. A board equation is a lot like the functions we saw before, but theyâ€™re specific to boards. The syntax is a bit different than before as well, so weâ€™ll go over it together. First, you want to declare the name of the equation, so weâ€™ll call ours <code class=\"language-plaintext highlighter-rouge\">gameBoard</code>.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>gameBoard : Board\n</code></pre>  </div></div>\n\n<p>Now that we have the first part of our function, we need to setup the next part. For function equations, you can clarify what you want the values of the spaces on the boards to be. Since we have a board of type <code class=\"language-plaintext highlighter-rouge\">Bool</code>, each space can have either a value of True or False.</p>\n\n<p>In our game we want to start by setting all our spaces to empty. With this board we can indicate we want to do this by setting each space to False. We could also decide to set all the spaces to True as well, but the choice is up to you!</p>\n\n<p>Now once we know what value we want to set all the spaces to, we write the following:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- for any (x,y) on board 'gameBoard'\n-- set that space to False\n-- So all the spaces are False!\ngameBoard!(x,y) = False\n</code></pre>  </div></div>\n<p>The syntax looks a bit odd, but letâ€™s break it down. First, <code class=\"language-plaintext highlighter-rouge\">gameBoard</code> is the name of the board equation weâ€™re defining here. Next, the <code class=\"language-plaintext highlighter-rouge\">!</code> is a special symbol that is used to say that this is a board equation. After that the <code class=\"language-plaintext highlighter-rouge\">(x,y)</code> describes for <em>which</em> spaces this equation will apply to. Finally, the result of <code class=\"language-plaintext highlighter-rouge\">False</code> is applied to each of those spaces.</p>\n\n<p>If we wanted to set a specific value to a specific space, we could values instead of <code class=\"language-plaintext highlighter-rouge\">(x,y)</code>, such as <code class=\"language-plaintext highlighter-rouge\">(1,1)</code>.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- set space 1,1 to True\ngameBoard!(1,1) = True\n</code></pre>  </div></div>\n\n<p>Now that we setup our board, itâ€™s on to setting up the function for playing our game. Much like before, weâ€™ll call this <code class=\"language-plaintext highlighter-rouge\">play</code>, and weâ€™ll have it take a <code class=\"language-plaintext highlighter-rouge\">Board</code> and give us a <code class=\"language-plaintext highlighter-rouge\">Result</code>.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>play : Board -&gt; Result\n</code></pre>  </div></div>\n\n<p>Weâ€™ll call the board that is given to this function <code class=\"language-plaintext highlighter-rouge\">b</code>, which could be the same as <code class=\"language-plaintext highlighter-rouge\">gameBoard</code>, but we donâ€™t want to assume that (as there could be other boards!).</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>play(b) = ...\n</code></pre>  </div></div>\n\n<p>Now, for handling input. Now, for playing a board game, asking for input would be like saying â€œtell me which space you want to go toâ€. Since we have coordinates for our board, the player can say â€œI would like to go to 1, 2â€, or â€œ2, 3â€. We want to be able to handle whatever space one the board the player could give us however. The way to handle this is to rephrase the question so the player says â€œI would like to go to X, Yâ€. Now, we can assume X and Y are placeholders for the actual positions we want to go to. X and Y represent what we refer to as <strong>variables</strong>, which are like names that describe values. Instead of having to describe how to play our game for every possible combination of (1,1) go there, (1,2) or here, (2,1) or here, (2,2) or hereâ€¦we can say for a <em>given</em> X and Y, go to that space there.</p>\n\n<p>Our board is only 2x2, but if we wanted to do this for a 20x20 or 100x100 board, you could see how this would take some time! Given that, variables can make our life much easier for describing what to do for any arrangement of these positions. Great, so now that we have an idea of X and Y that will represent our position, how do we write that out?</p>\n\n<p>First, we have a function called <code class=\"language-plaintext highlighter-rouge\">input</code> in BoGL we can use to read what the user types in. Since we defined the type of input earlier, we know it will be <code class=\"language-plaintext highlighter-rouge\">Int</code> when we use it. So, conceptually what we want to do is:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>Get Int X from input\nGet Int Y from input\n</code></pre>  </div></div>\n<p>But in BoGL to read into a variable we have to use whatâ€™s called a <strong>let expression</strong>. This is a basic way of describing that if we want a variable to be some value, we want to it to be some value for some purpose, specifically, for some <em>expression</em>. An example would be if we wanted to describe <code class=\"language-plaintext highlighter-rouge\">x + 5</code>, we would write out:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- let X be 5 in the following expression 'X + 5'\n-- which will give us 10\nlet X = 5 in X + 5\n</code></pre>  </div></div>\n\n<p>Since weâ€™re reading in a value from input, we want to use that instead, and that would be like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>let x = input in ...\n</code></pre>  </div></div>\n<p>And thatâ€™s the first part! But now weâ€™re missing the Y, so how do we work that in there. It turns out that we can write let expressions inside other let expressions. The effect is that we give X some value for an expression, where that expression is something that gives Y some value. That looks like:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- let x be an input value in an expression\n-- where y is also an input value\nlet x = input in\nlet y = input in ...\n</code></pre>  </div></div>\n<p>You could write this expression on 1 line, but this makes it a bit easier to read whatâ€™s going on.</p>\n\n<p>So now we have 2 <em>nested</em> let expressions. One on the outside that sets up X for an expression, and one on the inside that sets up Y. What we have left is the final expression that Y (and X) will be used in.</p>\n\n<p>In this last expression we want to indicate that if the space at (x,y) has a value of False, then P1Wins, otherwise P2Wins! We can utilize part of the same syntax we used for our board equation before, specifically the <code class=\"language-plaintext highlighter-rouge\">gameBoard!(x,y)</code> part. The best part is that we have a special X and Y that are from the player, and which should correspond to a space on the board. We can get the value for the space on this board, check it against True or False, and determine what the Result should be.</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- if the space at (x,y) is False, then P1 Wins\n-- otherwise P2 Wins\nif b!(x,y) == False then P1Wins else P2Wins\n</code></pre>  </div></div>\n\n<p>Putting the parts of this function together, we get the following:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>-- the indenting (tab/spacing) we use is just to make things a\n-- bit more readable again\nplay : Board -&gt; Result\nplay(b) = let x = input in\n          let y = input in\n            if b!(x,y) == False then P1Wins else P2Wins\n</code></pre>  </div></div>\n\n<p>With everything weâ€™ve written before, we should have:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>game OneTurn2\n\ntype Board = Array(2,2) of Bool\n\ntype Input = Int\ntype Player = {P1,P2}\ntype Result = {P1Wins, P2Wins}\n\ngameBoard : Board\ngameBoard!(x,y) = False\n\nplay : Board -&gt; Result\nplay(b) = let x = input in\n          let y = input in\n            if b!(x,y) == False then P1Wins else P2Wins\n</code></pre>  </div></div>\n\n<p>Now for playing this you can check your code in <a href=\"https://bogl.engr.oregonstate.edu/\">online tool</a> to verify everything looks correct. To play, youâ€™ll want to first type in <code class=\"language-plaintext highlighter-rouge\">play(gameBoard)</code>, since thatâ€™s the board we want to use (and <code class=\"language-plaintext highlighter-rouge\">b</code> describes the name for any board that was passed into that function). Once youâ€™ve done this youâ€™ll see a message that says youâ€™re in input mode. Now you can type in the following:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1\n1\n</code></pre>  </div></div>\n<p>So we give 1 to the first input, and 1 again to the second input, making (x,y) equal to (1,1). Finally we should see an output of <code class=\"language-plaintext highlighter-rouge\">P1Wins</code>, and thatâ€™s it, youâ€™ve successfully finished this exercise! If you want to type other things in, be sure to enter <code class=\"language-plaintext highlighter-rouge\">clear</code> first, as this resets the game you were playing so you can start everything again. If you type something and BoGL doesnâ€™t do what you expect, try typing <code class=\"language-plaintext highlighter-rouge\">clear</code> first to make sure everything is OK.</p>\n\n<p><a href=\"InARow\">Next, describing a game for items that are in a row.</a></p>\n","dir":"/tutorials/old/","name":"Input.md","path":"tutorials/old_tutorials/Input.md","url":"/tutorials/old/Input.html"},{"sort":7,"permalink":"tutorials/old/:basename:output_ext","layout":"default","title":"Board Count","content":"<h1 id=\"board-count\">Board Count</h1>\n\n<p><a href=\"InARow\">Previous Tutorial, In a Row</a>.</p>\n\n<p>â€¦This tutorial will be coming soon!â€¦</p>\n\n<p>If youâ€™ve gotten this far youâ€™re at the end of our tutorials! We hope that these exercises have been enlightening, and that you feel a bit better about what a programming language is about. The idea of BoGL is to give you an easy way to get started with programming. From here on out you may continue with BoGL, or you may try out a new language, but a lot of the concepts and ideas youâ€™ve learned here will hopefully be helpful going forward!</p>\n","dir":"/tutorials/old/","name":"BoardCount.md","path":"tutorials/old_tutorials/BoardCount.md","url":"/tutorials/old/BoardCount.html"}]